{"posts": [{"title": "<시작하세요! 도커/쿠버네티스> 소감", "preface": "전반부(~4장)은 도커, 그 이후(5~14장)는 k8s를 소개한다.k8s 공식 도큐먼트를 보기 전에 읽으면 딱 좋을 수준이다.책이 두껍지만 코드가 많아서, 그렇게까지 겁먹을 사이즈는 아니다. (다 읽고 나니 그런 생각이 들었다)x.509 적용 시작하면서 따라해보기를 포", "url": "https://velog.io/@roeniss", "author": "문성혁"}, {"title": "모델 경량화 4 - 행렬 분해(Filter Decomposition)", "preface": "행렬 분해 by 홍원의 마스터님, BoostCamp AI Tech 8주차", "url": "https://blogik.netlify.app/", "author": "김성익"}, {"title": "Go vs Java - Go에서의 객체 지향", "preface": "<img src=\"https://umi0410.github.io/blog/golang/go-vs-java-oop/declaration.png\" alt=\"Featured image of post Go vs Java - Go에서의 객체 지향\" /><h2 id=\"시작하며\">시작하며</h2>\n<p>요즘 <code>Go</code>와 <code>Java</code> 모두를 이용해 개발을 하다보니 각각의 장단점에 대해 느껴볼 수 있었다. <code>Go</code>는 리소스를 적게 먹으며 코드가 간결하고 라이브러리나 프레임워크 또한 심플해서 적용하기 편하다. <code>Java</code>는 이런 저런 기능이 많은 반면 그런 기능을 이용하기 위해 이해해야하는 내용들이 많고, 코드가 투명하지는 않다(다양한 Annotation을 이용하게 되면서 코드가 투명하게 그 동작을 나타내지 않음). Java의 장점 중에서는 특히나 <strong>객체지향의 대표적인 언어답게 상속과 다형성을 능력에 따라 자유자재로 이용</strong>할 수 있다는 점이 매력적이었다.</p>\n<p>Go 언어를 좋아하는 입장에서 개인적으로 이런 객체지향적인 특징이나 예외 처리를 제외하고는 딱히 Java가 Go에 비해 갖는 장점이 크게 느껴지지 않았다. 예외 처리는 Go가 바라보는 방향이 일반적인 예외 처리와 다르기에 어쩔 수 없지만, 객체지향적의 특징들은 어떻게 적용해볼 수 있을까하는 생각에 공부를 좀 해봤고 그 내용을 정리해본다. (<em>기회가 된다면 Go에서 error를 다루는 철학에 대해 추가적으로 공부해보고싶다.</em>)</p>\n<p>❗<strong>Go에 대한 기본적인 내용을 정리해보는 것이 아니라 객체 지향 관점에서 바라본 Go에 대한 내용을 정리해보는 것이므로 Go의 기초 내용에 대한 설명은 생략할 것이므로 Go에 대한 기초 이해가 없다면, 그 부분을 먼저 알아보는 것을 추천한다!</strong></p>\n<h3 id=\"예시-코드\">예시 코드</h3>\n<p>Go에서 객체 지향을 적용한 간단한 계산기 프로그램을 예시로 작성해보았다. 전체 소스코드를 다 볼 필요는 없겠지만 필요에 따라 참고할 수 있도록 아래와 같이 첨부한다.</p>\n<p><strong>main 패키지 - /main.go</strong></p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-go\" data-lang=\"go\"><span class=\"kn\">package</span> <span class=\"nx\">main</span>\n<span class=\"kn\">import</span> <span class=\"p\">(</span>\n<span class=\"s\">&#34;bufio&#34;</span>\n<span class=\"s\">&#34;calculator/calc&#34;</span>\n<span class=\"s\">&#34;fmt&#34;</span>\n<span class=\"s\">&#34;os&#34;</span>\n<span class=\"s\">&#34;strconv&#34;</span>\n<span class=\"s\">&#34;strings&#34;</span>\n<span class=\"p\">)</span>\n<span class=\"kd\">func</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\n<span class=\"kd\">var</span> <span class=\"p\">(</span>\n<span class=\"nx\">calculator</span> <span class=\"o\">*</span><span class=\"nx\">calc</span><span class=\"p\">.</span><span class=\"nx\">Calculator</span> <span class=\"p\">=</span> <span class=\"nx\">calc</span><span class=\"p\">.</span><span class=\"nf\">NewCalculator</span><span class=\"p\">()</span> <span class=\"c1\">// 계산기 struct\n</span><span class=\"c1\"></span> <span class=\"nx\">operationUnit</span> <span class=\"nx\">calc</span><span class=\"p\">.</span><span class=\"nx\">OperationUnit</span> <span class=\"c1\">// OperationUnit이라는 interface type을 통해 Polymorphism 이용\n</span><span class=\"c1\"></span> <span class=\"nx\">operationResult</span> <span class=\"kt\">float64</span> <span class=\"c1\">// 계산 결과를 담음\n</span><span class=\"c1\"></span> <span class=\"nx\">operationErr</span> <span class=\"kt\">error</span> <span class=\"c1\">// 계산 수행에 대한 error을 담음\n</span><span class=\"c1\"></span> <span class=\"p\">)</span>\n<span class=\"c1\">// main package에서는 calc package에 정의된 unexported name인 id에 접근할 수 없다.\n</span><span class=\"c1\"></span> <span class=\"c1\">//calculator.id = &#34;Jinsu Park&#34;\n</span><span class=\"c1\"></span>\n<span class=\"nx\">scanner</span> <span class=\"o\">:=</span> <span class=\"nx\">bufio</span><span class=\"p\">.</span><span class=\"nf\">NewScanner</span><span class=\"p\">(</span><span class=\"nx\">os</span><span class=\"p\">.</span><span class=\"nx\">Stdin</span><span class=\"p\">)</span>\n<span class=\"c1\">// 연산 option을 위해 값을 입력받기 (e.g. 1)\n</span><span class=\"c1\"></span> <span class=\"nx\">fmt</span><span class=\"p\">.</span><span class=\"nf\">Printf</span><span class=\"p\">(</span><span class=\"s\">`A simple calculator program.\n</span><span class=\"s\">=======================================================\n</span><span class=\"s\">Operation options\n</span><span class=\"s\">\n</span><span class=\"s\"> 1. Mulitply a, b float 64\n</span><span class=\"s\"> 2. Sqaure val, square float64\n</span><span class=\"s\">\n</span><span class=\"s\">Please input an int for your desired operation.\n</span><span class=\"s\">&gt;&gt;&gt; `</span><span class=\"p\">)</span>\n<span class=\"nx\">scanner</span><span class=\"p\">.</span><span class=\"nf\">Scan</span><span class=\"p\">()</span>\n<span class=\"nx\">option</span><span class=\"p\">,</span> <span class=\"nx\">_</span> <span class=\"o\">:=</span> <span class=\"nx\">strconv</span><span class=\"p\">.</span><span class=\"nf\">Atoi</span><span class=\"p\">(</span><span class=\"nx\">scanner</span><span class=\"p\">.</span><span class=\"nf\">Text</span><span class=\"p\">())</span>\n<span class=\"c1\">// args를 위해 입력받기 (e.g. 10 20)\n</span><span class=\"c1\"></span> <span class=\"nx\">fmt</span><span class=\"p\">.</span><span class=\"nf\">Printf</span><span class=\"p\">(</span><span class=\"s\">&#34;Please input floats as args.\\n&gt;&gt;&gt; &#34;</span><span class=\"p\">)</span>\n<span class=\"nx\">scanner</span><span class=\"p\">.</span><span class=\"nf\">Scan</span><span class=\"p\">()</span>\n<span class=\"nx\">inputs</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"nx\">_</span><span class=\"p\">,</span> <span class=\"nx\">input</span> <span class=\"o\">:=</span> <span class=\"k\">range</span> <span class=\"nx\">strings</span><span class=\"p\">.</span><span class=\"nf\">Split</span><span class=\"p\">(</span><span class=\"nx\">scanner</span><span class=\"p\">.</span><span class=\"nf\">Text</span><span class=\"p\">(),</span> <span class=\"s\">&#34; &#34;</span><span class=\"p\">){</span>\n<span class=\"nx\">f</span><span class=\"p\">,</span> <span class=\"nx\">_</span> <span class=\"o\">:=</span> <span class=\"nx\">strconv</span><span class=\"p\">.</span><span class=\"nf\">ParseFloat</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">)</span>\n<span class=\"nx\">inputs</span> <span class=\"p\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"nx\">inputs</span><span class=\"p\">,</span> <span class=\"nx\">f</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 연산에 대한 multiplexing. 즉 option에 따른 연산을 수행한다는 의미\n</span><span class=\"c1\"></span> <span class=\"c1\">// operationUnit이라는 OperationUnit interface type을 통해 Polymorphism 이용\n</span><span class=\"c1\"></span> <span class=\"k\">switch</span> <span class=\"nx\">option</span><span class=\"p\">{</span>\n<span class=\"k\">case</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n<span class=\"nx\">operationUnit</span> <span class=\"p\">=</span> <span class=\"nx\">calculator</span><span class=\"p\">.</span><span class=\"nx\">Multiplier</span>\n<span class=\"k\">case</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n<span class=\"nx\">operationUnit</span> <span class=\"p\">=</span> <span class=\"nx\">calculator</span><span class=\"p\">.</span><span class=\"nx\">SquareMultiplier</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// Operate라는 기능을 다양한 동작으로 수행할 수 있다.\n</span><span class=\"c1\"></span> <span class=\"nx\">operationResult</span><span class=\"p\">,</span> <span class=\"nx\">operationErr</span> <span class=\"p\">=</span> <span class=\"nx\">operationUnit</span><span class=\"p\">.</span><span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">inputs</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"c1\">// result\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"nx\">operationErr</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span><span class=\"p\">{</span>\n<span class=\"nx\">fmt</span><span class=\"p\">.</span><span class=\"nf\">Println</span><span class=\"p\">(</span><span class=\"s\">&#34;[Error]&#34;</span><span class=\"p\">,</span> <span class=\"nx\">operationErr</span><span class=\"p\">)</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span><span class=\"p\">{</span>\n<span class=\"nx\">fmt</span><span class=\"p\">.</span><span class=\"nf\">Println</span><span class=\"p\">(</span><span class=\"s\">&#34;Result:&#34;</span><span class=\"p\">,</span> <span class=\"nx\">operationResult</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><strong>calc 패키지 - /calc/calc.go</strong></p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-go\" data-lang=\"go\"><span class=\"kn\">package</span> <span class=\"nx\">calc</span>\n<span class=\"kn\">import</span> <span class=\"p\">(</span>\n<span class=\"s\">&#34;errors&#34;</span>\n<span class=\"p\">)</span>\n<span class=\"kd\">var</span> <span class=\"nx\">autoIncrementID</span> <span class=\"kt\">int</span> <span class=\"p\">=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">type</span> <span class=\"nx\">Calculator</span> <span class=\"kd\">struct</span><span class=\"p\">{</span>\n<span class=\"nx\">id</span> <span class=\"kt\">int</span> <span class=\"c1\">// 제조된 Calculator을 식별하기 위한 ID. 변수명이 소문자로 시작하므로 export 되지 않는다.\n</span><span class=\"c1\"></span> <span class=\"nx\">Multiplier</span> <span class=\"nx\">OperationUnit</span>\n<span class=\"nx\">SquareMultiplier</span> <span class=\"nx\">OperationUnit</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">OperationUnit</span> <span class=\"kd\">interface</span><span class=\"p\">{</span>\n<span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"kt\">bool</span>\n<span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">MultiplyOperationUnit</span> <span class=\"kd\">struct</span><span class=\"p\">{}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">SquareOperationUnit</span> <span class=\"kd\">struct</span><span class=\"p\">{</span>\n<span class=\"nx\">MultiplyOperationUnit</span> <span class=\"c1\">// Embed의 예시\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"kd\">func</span> <span class=\"nf\">NewCalculator</span><span class=\"p\">()</span> <span class=\"o\">*</span><span class=\"nx\">Calculator</span><span class=\"p\">{</span>\n<span class=\"nx\">c</span> <span class=\"o\">:=</span> <span class=\"o\">&amp;</span><span class=\"nx\">Calculator</span><span class=\"p\">{</span>\n<span class=\"nx\">id</span><span class=\"p\">:</span> <span class=\"nx\">autoIncrementID</span><span class=\"p\">,</span>\n<span class=\"nx\">Multiplier</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">{},</span>\n<span class=\"nx\">SquareMultiplier</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nx\">SquareOperationUnit</span><span class=\"p\">{</span><span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">:</span> <span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">{}},</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">autoIncrementID</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n<span class=\"k\">return</span> <span class=\"nx\">c</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">unit</span> <span class=\"o\">*</span><span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">)</span> <span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"kt\">bool</span><span class=\"p\">{</span>\n<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">{</span>\n<span class=\"k\">return</span> <span class=\"kc\">false</span>\n<span class=\"p\">}</span>\n<span class=\"k\">return</span> <span class=\"kc\">true</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">unit</span> <span class=\"o\">*</span><span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">)</span> <span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">){</span>\n<span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">unit</span><span class=\"p\">.</span><span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"o\">...</span><span class=\"p\">){</span>\n<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">errors</span><span class=\"p\">.</span><span class=\"nf\">New</span><span class=\"p\">(</span><span class=\"s\">&#34;MultiplyOperationUnit의 args가 유효하지 않습니다.&#34;</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"k\">return</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"kc\">nil</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">//func (unit *SquareOperationUnit) IsValidInput(args ...float64) bool{\n</span><span class=\"c1\">// ... 필요에 따라 정의하면 Override처럼 이용 가능\n</span><span class=\"c1\">//}\n</span><span class=\"c1\"></span>\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">unit</span> <span class=\"o\">*</span><span class=\"nx\">SquareOperationUnit</span><span class=\"p\">)</span> <span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">){</span>\n<span class=\"c1\">// *SquareOperationUnit에 대한 IsValidInput 메소드는 정의한 적 없지만\n</span><span class=\"c1\"></span> <span class=\"c1\">// Embedding을 통해 일반적인 OOP에서 부모의 메소드를 이용하듯이 이용 가능.\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">unit</span><span class=\"p\">.</span><span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"o\">...</span><span class=\"p\">){</span>\n<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">errors</span><span class=\"p\">.</span><span class=\"nf\">New</span><span class=\"p\">(</span><span class=\"s\">&#34;SquareOperationUnit의 args가 유효하지 않습니다.&#34;</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">var</span> <span class=\"p\">(</span>\n<span class=\"c1\">// val^square 즉 &#34;val의 square 제곱&#34;에 대한 계산\n</span><span class=\"c1\"></span> <span class=\"nx\">val</span> <span class=\"p\">=</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"nx\">square</span> <span class=\"p\">=</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"nx\">reduced</span> <span class=\"kt\">float64</span> <span class=\"p\">=</span> <span class=\"nx\">val</span> <span class=\"c1\">// 제곱 연산 중 값을 담아 놓는 변수\n</span><span class=\"c1\"></span> <span class=\"nx\">cnt</span> <span class=\"p\">=</span> <span class=\"nb\">float64</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">// 제곱 연산 루프를 위한 counter\n</span><span class=\"c1\"></span> <span class=\"nx\">err</span> <span class=\"kt\">error</span>\n<span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"p\">;</span><span class=\"nx\">cnt</span> <span class=\"p\">&lt;</span> <span class=\"nx\">square</span><span class=\"p\">;</span> <span class=\"nx\">cnt</span> <span class=\"o\">++</span><span class=\"p\">{</span>\n<span class=\"nx\">reduced</span><span class=\"p\">,</span> <span class=\"nx\">err</span> <span class=\"p\">=</span> <span class=\"nx\">unit</span><span class=\"p\">.</span><span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">.</span><span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">reduced</span><span class=\"p\">,</span> <span class=\"nx\">val</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"nx\">err</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span><span class=\"p\">{</span>\n<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">err</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">return</span> <span class=\"nx\">reduced</span><span class=\"p\">,</span> <span class=\"nx\">err</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><figure style=\"flex-grow: 181; flex-basis: 435px\">\n<a href=\"https://umi0410.github.io/blog/golang/go-vs-java-oop/preview.png\" data-size=\"557x307\"><img src=\"https://umi0410.github.io/blog/golang/go-vs-java-oop/preview.png\"\nsrcset=\"https://umi0410.github.io/blog/golang/go-vs-java-oop/preview_hu606630559448eebea4de9d8c902ece24_23429_480x0_resize_box_2.png 480w, https://umi0410.github.io/blog/golang/go-vs-java-oop/preview_hu606630559448eebea4de9d8c902ece24_23429_1024x0_resize_box_2.png 1024w\"\nwidth=\"557\"\nheight=\"307\"\nloading=\"lazy\"\nalt=\"preview.png\">\n</a>\n<figcaption>preview.png</figcaption>\n</figure></p>\n<p><figure style=\"flex-grow: 114; flex-basis: 274px\">\n<a href=\"https://umi0410.github.io/blog/golang/go-vs-java-oop/declaration.png\" data-size=\"406x355\"><img src=\"https://umi0410.github.io/blog/golang/go-vs-java-oop/declaration.png\"\nsrcset=\"https://umi0410.github.io/blog/golang/go-vs-java-oop/declaration_hu2809de309117ad963d612eaa5a399aab_35836_480x0_resize_box_2.png 480w, https://umi0410.github.io/blog/golang/go-vs-java-oop/declaration_hu2809de309117ad963d612eaa5a399aab_35836_1024x0_resize_box_2.png 1024w\"\nwidth=\"406\"\nheight=\"355\"\nloading=\"lazy\"\nalt=\"declaration.png\">\n</a>\n<figcaption>declaration.png</figcaption>\n</figure></p>\n<ul>\n<li>Calculator라는 계산기 <code>struct</code>가 존재\n<ul>\n<li>✨ <code>id</code> field는 소문자로 시작하기때문에 외부에서 함부로 접근할 수 없도록 data를 <code>캡슐화</code></li>\n</ul>\n</li>\n<li>계산기에서 각각의 연산을 담당하는 OperationUnit <code>interface</code>존재</li>\n<li>OperationUnit <code>interface</code>는 Input의 유효성을 검사하는 IsValidInput 메소드와 연산을 수행하는 Operate 메소드 존재</li>\n<li>각각의 연산을 담당하는 Unit은 OperationUnit interface가 정의한 메소드들을 구현함으로써 duck-typing을 통해 OperationUnit interface로 사용된다. ⇒ ✨ interface를 통한 <code>추상화</code>와 <code>다형성</code> 이용 가능\n<ul>\n<li>OperationUnit interface로 사용이 가능한 struct의 예시\n<ul>\n<li>MultiplyOperationUnit struct - 곱셈 연산을 담당</li>\n<li>SquareOperationUnit struct - 제곱셈 연산을 담당\n<ul>\n<li>✨ <code>Embed</code>를 통해 MultiplyOperationUnit을 <code>상속</code>한 것처럼 field와 method를 사용 가능</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"객체지향적-관점에서의-go에-대해\">객체지향적 관점에서의 Go에 대해</h2>\n<p>Go는 아무래도 객체 지향 언어라고 하지는 않는 듯하다. 이에 대해선 다양한 의견이 있는 것 같은데 Post-OOP 언어라는 사람도 있고 OOP 언어는 아니지만 Object-Oriented하게 할 수 있으므로 OOP 언어이면서 OOP언어가 아니라는 사람도 있다.</p>\n<p>OOP에는 크게 4가지 원칙이 있다.</p>\n<ol>\n<li>연관된 변수와 함수를 클래스로 묶으며 외부에서 특정 데이터나 기능에 접근하지 못하도록 하는 정보를 은닉해주는 <strong>캡슐화</strong></li>\n<li>부모 객체의 field, method를 자식 객체가 이용할 수 있도록해주고, Override할 수 있게 해주는 <strong>상속</strong></li>\n<li>세부 사항은 제외하고, 어떤 기능이 존재하는지 등의 추상적인 정보만으로도 이용할 수 있게 해주는 <strong>추상화</strong></li>\n<li>즉 하나의 타입이 여러 타입으로 이용될 수 있으며, 각각이 다양하게 동작할 수 있는 <strong>다형성</strong></li>\n</ol>\n<p>그리고 대표적인 OOP 언어인 <code>Java</code>는 이러한 내용들을 아주 잘 이용할 수 있게끔 되어있다. OOP 언어가 아닌 <code>Go</code>에서 이러한 <strong>OOP의 특징이자 장점인 요소들을 어떻게 적용할 수 있을지</strong> 알아보도록하겠다.</p>\n<h2 id=\"-encapsulation캡슐화\">💊 Encapsulation(캡슐화)</h2>\n<p>Go에서는 Export를 통해 캡슐화를 이용할 수 있다. Export에 대해 간단히 설명하자면 private, public 을 이용해 변수나 함수에 접근 제한을 두는 것이 아니라 이름이 대문자냐 소문자냐에 따라 패키지 외부에서 접근을 제어하는 것을 말한다.</p>\n<p>Go의 Export 이용 방법은 많이 찾아볼 수 있으니 캡슐화에 초점을 맞춘 그 쓰임에 대해 알아본다.</p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-bash\" data-lang=\"bash\">// Calculator에 대한 정의와 구현을 담당하는 calc 패키지\npackage calc\n<span class=\"nb\">type</span> Calculator struct<span class=\"o\">{</span>\nID int // 제조된 Calculator을 식별하기 위한 ID. 변수명이 소문자로 시작하므로 <span class=\"nb\">export</span> 되지 않는다.\n...\n<span class=\"o\">}</span>\n</code></pre></div><p>위와 같이 Calculator를 정의하는 calc라는 패키지가 있다고 가정하다. Calculator를 식별하는 ID에 대한 작업은 calc 패키지에서 담당하고 함부로 외부에서 값을 바꾸지 못하도록하고싶은 경우 field가 소문자로 시작하도록 함으로써 외부 패키지에서 직접 접근하지 못하도록할 수 있다.</p>\n<p>필요에 따라 Java에서 그러하듯 getter와 setter를 정의해줄 수도 있다.</p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-bash\" data-lang=\"bash\">package main\n...\nfunc main<span class=\"o\">(){</span>\nvar <span class=\"o\">(</span>\ncalculator *calc.Calculator <span class=\"o\">=</span> calc.NewCalculator<span class=\"o\">()</span>\n<span class=\"o\">)</span>\n// main package에서는 calc package에 정의된 unexported name인 id에 접근할 수 없다.\n//calculator.id <span class=\"o\">=</span> <span class=\"s2\">&#34;Jinsu Park&#34;</span>\n<span class=\"o\">}</span>\n</code></pre></div><p>앞서 말했듯이 이렇게 calc 패키지가 아닌 외부 패키지(예를 들어 main 패키지)에서는 unexported name인 id에 접근할 수 없다.</p>\n<p>주로 캡슐화와 Go에 대해선 은닉을 어떻게 하는가가 요점이라고 생각해 이 부분에 대해 다뤄보았다.</p>\n<blockquote>\n<p>자세한 내용은? - 연관된 변수와 함수를 묶어주는 내용은 Go의 struct, receiver와 method 등에 대해 검색해보면 더 깊이 알아볼 수 있다.</p>\n</blockquote>\n<h2 id=\"-inheriatance상속\">👩‍👧‍👦 Inheriatance(상속)</h2>\n<p>Go는 Composition을 이용한 Embedding이라는 방식을 통해 Inheritance와 같은 기능을 이용할 수 있게 해준다는 식으로 많이들 설명을 하는 것 같았으나 주관적인 해석을 해보자면 Go의 <code>Embedding</code>은 <strong>Composition이면서 자동으로 embed된 field의 method와 본인의 method인 것처럼 사용할 수 있게 해주기에 Inheritance처럼 이용</strong>할 수 있다고 볼 수 있겠다.</p>\n<p>Go의 Embedding은 struct의 field에 별도의 name이 아닌 type만을 적어줌으로써 이용할 수 있다. B라는 type이 는 메소드 Say()를 가지고 있는 경우 struct A가 type B를 Embed한다면 A는 B의 Say 메소드를 두 가지 방법으로 이용 가능하다.</p>\n<ol>\n<li><code>A.Say()</code> - 이경우 암묵적으로 2.로 변환되어 수행되는 셈</li>\n<li><code>A.B.Say()</code> - 이렇게 명시적으로 <code>Selector</code>(여기선 B)를 적어줄 수도 있다. 일반적인 <code>Composition</code>과 동일하다.</li>\n</ol>\n<p><em>Go에서 Embedding을 사용하는 방법 자체 또한 많은 내용을 인터넷에서 찾아볼 수 있으니 <strong>상속과 Embedding에 초점을 맞춰 설명해보도록하겠다.</strong></em></p>\n<p>일반적인 객체 지향적인 방식에서는 <code>type MultiplyOperationUnit struct</code> 라는 type이 존재하고</p>\n<p><code>type SquareOperationUnit struct</code> 가 <code>MultiplyOperationUnit</code> type을 상속받는다면 SquareOperationUnit은 IsValidCheck 메소드를 비롯한 MultiplyOperationUnit의 메소드와 멤버 변수를 이용할 수 있을 것이다.</p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-go\" data-lang=\"go\"><span class=\"kd\">type</span> <span class=\"nx\">MultiplyOperationUnit</span> <span class=\"kd\">struct</span><span class=\"p\">{}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">SquareOperationUnit</span> <span class=\"kd\">struct</span><span class=\"p\">{</span>\n<span class=\"nx\">MultiplyOperationUnit</span> <span class=\"c1\">// type만을 전달함으로써 Embed\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"c1\">// 곱셈 연산에 대한 Input validation\n</span><span class=\"c1\"></span><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">unit</span> <span class=\"o\">*</span><span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">)</span> <span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"kt\">bool</span><span class=\"p\">{</span>\n<span class=\"nx\">fmt</span><span class=\"p\">.</span><span class=\"nf\">Println</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">{</span>\n<span class=\"k\">return</span> <span class=\"kc\">false</span>\n<span class=\"p\">}</span>\n<span class=\"k\">return</span> <span class=\"kc\">true</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">unit</span> <span class=\"o\">*</span><span class=\"nx\">MultiplyOperationUnit</span><span class=\"p\">)</span> <span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">){</span>\n<span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">unit</span><span class=\"p\">.</span><span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"o\">...</span><span class=\"p\">){</span>\n<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">errors</span><span class=\"p\">.</span><span class=\"nf\">New</span><span class=\"p\">(</span><span class=\"s\">&#34;MultiplyOperationUnit의 args가 유효하지 않습니다.&#34;</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"o\">...</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">unit</span> <span class=\"o\">*</span><span class=\"nx\">SquareOperationUnit</span><span class=\"p\">)</span> <span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">){</span>\n<span class=\"c1\">// *SquareOperationUnit에 대한 IsValidInput 메소드는 정의한 적 없지만\n</span><span class=\"c1\"></span> <span class=\"c1\">// Embedding을 통해 일반적인 OOP에서 부모의 메소드를 이용하듯이 이용 가능.\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">unit</span><span class=\"p\">.</span><span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"o\">...</span><span class=\"p\">){</span>\n<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">errors</span><span class=\"p\">.</span><span class=\"nf\">New</span><span class=\"p\">(</span><span class=\"s\">&#34;SquareOperationUnit의 args가 유효하지 않습니다.&#34;</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"o\">...</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>이 경우 Go에서는 SquareOperationUnit이 MultiplyOperationUnit을 Embed하도록 한다. 평범한 Compostion 방식으로 이용할 수 있겠지만 Go의 특이한 Embed 방식을 이용함으로써 <code>*SquareOperationUnit</code> 에 대한 <code>IsValidInput</code> <strong>메소드를 정의한 적 없지만 일반 OOP에서 부모 클래스에 정의된 메소드를 이용하듯<code>unit *SquareOperationUnit</code>과 같이 이용 가능</strong>하다.</p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-go\" data-lang=\"go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">unit</span> <span class=\"o\">*</span><span class=\"nx\">SquareOperationUnit</span><span class=\"p\">)</span> <span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">){</span>\n<span class=\"o\">...</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>OOP에서의 Method Override와 같은 작업을 Go에서 하고싶다면 위와 같이 추가적으로 자신의 타입에 대한 method를 정의하면된다. 메소드를 추가적으로 정의해준 뒤 Selector를 지정하지 않으면 당연히 우리가 바란대로 Embed된 type의 method가 아닌 자기 자신의 method를 호출하게 된다.</p>\n<blockquote>\n<p>자세한 내용은? - 아무래도 Go의 Embedding과 Composition에 대한 이해가 없다면 무슨 말인지 이해하기 힘들 수 있다. 따라서 해당 내용들에 대해 알아볼 것을 추천!</p>\n</blockquote>\n<h2 id=\"abstraction추상화\">Abstraction(추상화)</h2>\n<p>추상화는 그 객체의 세부 내용이 아닌 공통된 기능을 바탕으로 추려내는 것을 의미한다.</p>\n<p>추상화에 있어서는 Java와 Go가 interface를 이용한다는 점에서 크게 다르진 않다.</p>\n<p>interface에 추상적으로 해당 interface를 구현하는 type들이 구현하기를 바라는 method를 정의만한다.</p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-go\" data-lang=\"go\"><span class=\"kd\">type</span> <span class=\"nx\">OperationUnit</span> <span class=\"kd\">interface</span><span class=\"p\">{</span>\n<span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"kt\">bool</span>\n<span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>이 경우 OperationUnit는 &ldquo;IsValidInput과 Operate 기능을 수행할 수 있는 무언가&rdquo; 이라고 추상화된 것이다.</p>\n<blockquote>\n<p>자세한 내용은? - 추상화의 쓰임은 다형성의 쓰임과도 밀접한 연관이 있다. Go에서 interface를 사용하는 패턴과 사용법에 대해 알아보면 좋을 것 같다.</p>\n</blockquote>\n<h2 id=\"-polymorphism다형성\">🌒🌓🌕 Polymorphism(다형성)</h2>\n<p><code>다형성</code>이란 <strong>한 가지 타입이 경우에 따라 같은 기능에 대해 다양한 동작을 수행</strong>할 수 있는 것을 말한다. <strong>추상화는 interface에 대한 정의</strong>에 해당하고 <strong>다형성은 interface 활용</strong>에 해당하는 듯하다.</p>\n<p>일반적인 OOP 언어에서는 interface가 아닌 상속 관계에서도 부모⇒자식으로 타입 변환을 통해 다형성 활용이 가능하다. 하지만 Go는 이를 지원하지 않는다. 이유는 런타임에 동적으로 method dispatch(해당 type의 객체 혹은 value가 어떤 함수를 메소드로 할 지 결정하는 것)을 수행함으로 인한 오버헤드를 줄이기 위해서 컴파일 타임에 정적으로 method dispatch할 수 있게 하기 위해서라고한다.</p>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-go\" data-lang=\"go\"><span class=\"kd\">type</span> <span class=\"nx\">OperationUnit</span> <span class=\"kd\">interface</span><span class=\"p\">{</span>\n<span class=\"nf\">IsValidInput</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"kt\">bool</span>\n<span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">args</span> <span class=\"o\">...</span><span class=\"kt\">float64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">float64</span><span class=\"p\">,</span> <span class=\"kt\">error</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">MultiplyOperationUnit</span> <span class=\"kd\">struct</span><span class=\"p\">{}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">SquareOperationUnit</span> <span class=\"kd\">struct</span><span class=\"p\">{</span>\n<span class=\"nx\">MultiplyOperationUnit</span>\n<span class=\"p\">}</span>\n<span class=\"o\">...</span> <span class=\"nx\">각종</span> <span class=\"nx\">메소드</span> <span class=\"nx\">정의</span> <span class=\"nx\">생략</span>\n<span class=\"kd\">func</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\n<span class=\"kd\">var</span> <span class=\"p\">(</span>\n<span class=\"nx\">calculator</span> <span class=\"o\">*</span><span class=\"nx\">calc</span><span class=\"p\">.</span><span class=\"nx\">Calculator</span> <span class=\"p\">=</span> <span class=\"nx\">calc</span><span class=\"p\">.</span><span class=\"nf\">NewCalculator</span><span class=\"p\">()</span>\n<span class=\"nx\">operationUnit</span> <span class=\"nx\">calc</span><span class=\"p\">.</span><span class=\"nx\">OperationUnit</span>\n<span class=\"nx\">operationResult</span> <span class=\"kt\">float64</span>\n<span class=\"nx\">operationErr</span> <span class=\"kt\">error</span>\n<span class=\"p\">)</span>\n<span class=\"c1\">// 연산에 대한 multiplexing. 즉 option에 따른 연산을 수행한다는 의미\n</span><span class=\"c1\"></span> <span class=\"k\">switch</span> <span class=\"nx\">option</span><span class=\"p\">{</span>\n<span class=\"k\">case</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n<span class=\"nx\">operationUnit</span> <span class=\"p\">=</span> <span class=\"nx\">calculator</span><span class=\"p\">.</span><span class=\"nx\">Multiplier</span>\n<span class=\"k\">case</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n<span class=\"nx\">operationUnit</span> <span class=\"p\">=</span> <span class=\"nx\">calculator</span><span class=\"p\">.</span><span class=\"nx\">SquareMultiplier</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">operationResult</span><span class=\"p\">,</span> <span class=\"nx\">operationErr</span> <span class=\"p\">=</span> <span class=\"nx\">operationUnit</span><span class=\"p\">.</span><span class=\"nf\">Operate</span><span class=\"p\">(</span><span class=\"nx\">inputs</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"c1\">// result\n</span><span class=\"c1\"></span> <span class=\"k\">if</span> <span class=\"nx\">operationErr</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span><span class=\"p\">{</span>\n<span class=\"nx\">fmt</span><span class=\"p\">.</span><span class=\"nf\">Println</span><span class=\"p\">(</span><span class=\"s\">&#34;[Error]&#34;</span><span class=\"p\">,</span> <span class=\"nx\">operationErr</span><span class=\"p\">)</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span><span class=\"p\">{</span>\n<span class=\"nx\">fmt</span><span class=\"p\">.</span><span class=\"nf\">Println</span><span class=\"p\">(</span><span class=\"s\">&#34;Result:&#34;</span><span class=\"p\">,</span> <span class=\"nx\">operationResult</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>operationUnit이라는 Interface에 다른 type의 struct인 calculator.Multiplier와 calculator.SquareMultiplier가 담길 수 있다.</p>\n<p>이를 통해 <code>operationUnit.Operate()</code> 는 <strong>경우에 따라 &ldquo;<em>연산</em>&ldquo;이라는 기능으로 <em>Multipliy</em> 작업을 수행할 수도 있고, <em>SqaureMultipliy</em> 작업을 수행할 수도 있는데, 이를 다형성</strong>이라고 한다.</p>\n<h2 id=\"go에서의-객체-지향의-한계점과-장점\">Go에서의 객체 지향의 한계점과 장점</h2>\n<div class=\"highlight\"><pre class=\"chroma\"><code class=\"language-go\" data-lang=\"go\"><span class=\"nx\">public</span> <span class=\"nx\">class</span> <span class=\"nx\">Example</span> <span class=\"p\">{</span>\n<span class=\"nx\">public</span> <span class=\"nx\">static</span> <span class=\"nx\">void</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"nx\">String</span><span class=\"p\">[]</span> <span class=\"nx\">args</span><span class=\"p\">){</span>\n<span class=\"c1\">// Parent class와 Parent를 extends한 Child class에 대한 구현은 생략한다.\n</span><span class=\"c1\"></span> <span class=\"nx\">Parent</span> <span class=\"nx\">parent</span> <span class=\"p\">=</span> <span class=\"nx\">new</span> <span class=\"nf\">Parent</span><span class=\"p\">();</span>\n<span class=\"nx\">Parent</span> <span class=\"nx\">child</span> <span class=\"p\">=</span> <span class=\"nx\">new</span> <span class=\"nf\">Child</span><span class=\"p\">();</span>\n<span class=\"nx\">parent</span><span class=\"p\">.</span><span class=\"nf\">ShowMetaData</span><span class=\"p\">();</span> <span class=\"c1\">// parent.GetName() 이용\n</span><span class=\"c1\"></span> <span class=\"cm\">/* Output\n</span><span class=\"cm\"> =======================================\n</span><span class=\"cm\"> Name: Parent\n</span><span class=\"cm\"> =======================================\n</span><span class=\"cm\"> */</span>\n<span class=\"nx\">child</span><span class=\"p\">.</span><span class=\"nf\">ShowMetaData</span><span class=\"p\">();</span> <span class=\"c1\">// child.GetName()이용.\n</span><span class=\"c1\"></span> <span class=\"c1\">// 이 때에는 .ShowMetaData()가 Parent class가 아닌 Child class가 Override한 GetName() 이용\n</span><span class=\"c1\"></span> <span class=\"cm\">/* Output\n</span><span class=\"cm\"> =======================================\n</span><span class=\"cm\"> Name: Child of Parent\n</span><span class=\"cm\"> =======================================\n</span><span class=\"cm\"> */</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>객체 지향 프로그래밍에선 <strong>부모 클래스에 정의된 메소드가 내부에서 자식이 Override한 메소드를 이용할 수도 있는데, Go는 그런 기능은 이용할 수 없다는 점이 가장 큰 한계점</strong>인 것 같다.</p>\n<p>예를 들어 Parent class의 .ShowMetaData()라는 method가 .GetName()이라는 메소드를 호출하는 경우, java에서는 Child가 GetName을 Override하면 child.ShowMetaData() 호출 시에 Child가 Override한 child.GetName()을 이용하지만, Go는 그럴 수 없다. 필요한 경우 함수를 인자나 field로 전달함으로써 사용할 수 있겠지만, 사용성이 제한적이다. 이 내용에 대해 여기서 설명하면 글이 길어질 것 같아 자세한 묘사는 생략하겠다.</p>\n<p>반면 Go에서의 객체 지향은 <strong>장점</strong>은 이 글(<a class=\"link\" href=\"https://www.toptal.com/go/golang-oop-tutorial\" target=\"_blank\" rel=\"noopener\"\n>https://www.toptal.com/go/golang-oop-tutorial</a>)의 후반부에 잘 나와있는데, <strong>굳이 Java를 이용하지 않아도 이렇게 OOP가 충분히 가능하다</strong>는 것이 핵심이다. Java의 VM/JIT으로 인한 리소스 부족, 자유도가 떨어지는 프레임워크, 많은 annotation, &hellip; 등등의 단점 없이도 충분히 Go를 통해 가볍게 OOP 할 수 있다는 것이 장점이다.</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>아무래도 객체 지향적 개발을 하는 데에 있어서는 Java가 좀 더 직관적으로 그대로 설계, 구현해서 이용이 가능한 것 같다. 처음 Java를 공부했을 때부터 Java는 객체지향적으로 개발하는 패턴에 대해 수없이 많은 예제가 존재했고, 그 패턴이 명확했던 반면 Go는 명확한 패턴이나 깔끔하게 정의가 없다(<em>이런 식으로 OOP 원칙을 이용해볼 수 있지 않을까~ 정도</em>). 아마 애초에 Go는 객체 지향 언어로 설계하지 않았기 때문이 아닐까싶다.</p>\n<p>이를 계기로 Go에서는 OOP 원칙들이 어떻게 다양하게 적용할 수 있는지 좀 더 자세히 알아볼 수 있었다.</p>\n<h2 id=\"참고\">참고</h2>\n<ul>\n<li>[번역] Go와 OOP - <a class=\"link\" href=\"https://mingrammer.com/translation-go-and-oop/\" target=\"_blank\" rel=\"noopener\"\n>https://mingrammer.com/translation-go-and-oop/</a></li>\n<li>Golang OOP tutorial - <a class=\"link\" href=\"https://www.toptal.com/go/golang-oop-tutorial\" target=\"_blank\" rel=\"noopener\"\n>https://www.toptal.com/go/golang-oop-tutorial</a></li>\n<li>go object-oriented - <a class=\"link\" href=\"https://golangkorea.github.io/post/go-start/object-oriented/\" target=\"_blank\" rel=\"noopener\"\n>https://golangkorea.github.io/post/go-start/object-oriented/</a></li>\n</ul>", "url": "https://umi0410.github.io/", "author": "박진수"}, {"title": "[독서] 훌륭한 프로그래머 되는 법(3편)", "preface": "", "url": "https://choheeis.github.io/newblog/archive/", "author": "김초희"}, {"title": "쿠버네티스 디플로이먼트(Deployment) - 선언적인 애플리케이션 업데이트", "preface": "쿠버네티스에서 애플리케이션의 선언적 업데이트를 가능하게 하는 디플로이먼트 리소스에 대해서 알아봅시다", "url": "https://blog.eunsukim.me", "author": "김은수"}, {"title": "본격 HTTP 쿠키 삽질기", "preface": "쿠키가 마녀에게 잡혀 있던 이유가 있었다.오븐브레이크가 아니라 멘탈브레이크였다.쿠키런때부터 인성 알아봤다.(인성 문제있어?)그렇게 탈출을 도와주려고 했는데... 쿠키 넌 개인주의야intro.#거진 2-3주에 걸친 쿠키 삽질기를 녹여낸 글입니다. 브라우저에서 쿠키를 사용할 때 엄청 애를 먹었습니다. stack overflow나 MDN를 읽는 것만으로 알기 어려운 내용도 일부 포함하였습니다.이 글을 통해서 기본적인 쿠키의 개념들과 제가 겪었던 문제의 해결법을 같이 기술하겠습니다.", "url": "https://yoonhoGo.github.io/blog", "author": "고윤호"}, {"title": "React 상태 관리의 과거, 현재, 그리고 미래", "preface": "React 앱에서 사용되는 다양한 유형의 상태를 알아보고, 이를 효과적으로 제어하기 위한 라이브러리들을 살펴봅니다.", "url": "https://velog.io/@cadenzah", "author": "김정모"}, {"title": "프론트엔드 환경 최적화 (vue를 곁들인..)", "preface": "회사에서 일하면서 점점 프로젝트가 커질수록, 성능의 중요성을 느꼈기 때문에 열심히 체크리스트를 만들고 성능 최적화에 도전하고 있다. 그 중 가장 기초적인 최적화를 진행했던 경험에 대해 적어보려고 한다.최신 프론트엔드 환경을 개선하기 위해 꼭 필요한 도구는 Webpack", "url": "https://velog.io/@sian", "author": "이시연"}, {"title": "RDB의 동시성과 일관성 이슈를 어떻게 처리할 것인가?", "preface": "웹서비스 중에 RDBMS를 채택하지 않는 경우는 드물다고 생각한다. 요즘은 ORM이 특화되어 Query를 잘 모르더라도 개발자들이 RDB를 능숙하게 다룰 수 있는 시대가 왔지만, 결제/재고 등 민감한 비즈니스를 다루는 환경에서는 RDBMS에 대하여 좀 더 깊은 지식이", "url": "https://velog.io/@p4rksh", "author": "박상훈"}, {"title": "AWS S3, Cloudfront, Route53과 github Action으로 정적 웹페이지 배포, 호스팅 자동화하기", "preface": "들어가기 전에", "url": "https://binaryflavor.com/", "author": "변준석"}, {"title": "[React] 동시성(Concurrent) 모드 그리고 Recoil", "preface": "최종 수정일: 2021. 06. 15", "url": "https://k-dev.medium.com", "author": "고명진"}, {"title": "부동산 투자에서의 레버리지 효과와 위험성", "preface": "레버리지 효과란? 레버리지 효과(leverage effect)란 타인이나 금융기관으로부터 차입한 자본을 이용하여 자기자본이익률을 높이는 것을 말한다. 빌린 돈을 지렛대(lever) 삼아 이익을 창출한다는 의미에서 지렛대 효과라고도 한다. 지렛대를 사용하면 작은 힘으로 무거운 무게를 들 수 있는데, 차입한 자본이 지렛대가 되고 그 힘이 나의 자본과 합쳐져서 높은 수익을 낼 수 있다는 의미이다. 즉, 자신의 자본을 최소화하고 타인의 자본을 빌려 수익률을 극대화하는 것이다. 예를 들어 A와 B가 동일하게 1년동안 10억원을 투자하여 2억원의 순이익을 얻었다. A는 대출 없이 자신의 돈 10억원을 투자하였으며, B는 은행에서 대출받은 5억원과 자신의 돈 5억원을 합쳐 투자하였다. A와 B 모두 총자본이익률은 2..", "url": "https://suyeon96.tistory.com/", "author": "우수연"}, {"title": "안드로이드 문서 정리 - 인라인 복합 xml 리소스", "preface": "", "url": "https://yebon-kim.tistory.com/", "author": "김예본"}, {"title": "[2-3] 3) 데이터 계층 - 블록체인", "preface": "블록체인 어카운트의 상태 전이를 유발하는 트랜잭션들과 모든 관련 정보는 블록이라는 구조체에 저장됨 블록들은 시간순으로 체인처럼 연결되어있음 P2P 네트워크와 동기화 프로토콜을 통해 네트워크에 연결된 모든 노드에 전파되어 공유됨 블록 블록 헤더, 엉클 블록, 트랜잭션으로 구성됨 블록을 체인에 추가할 때 필요한 마이닝 작업의 난이도도 포함되어 있음 Etherscan.io 이더리움의 모든 정보를 탐색하고 조회할 수 있는 서비스 제공 실제 이더리움 네트워크에 참여해 모든 정보를 동기화해서 정보를 MongoDB로 옮긴 후 분석 type Bloom [32]byte type Header struct { ParentHash common.Hash UncleHash common.Hash Coinbase common.Has..", "url": "https://victoria-k.tistory.com/", "author": "권주희"}, {"title": "serverless framework로 간단한 CRUD 백엔드 어플리케이션 만들기 - 개념편", "preface": "Abstract\n본인의 프리랜스 과정에서 경험한 serverless framework를 이용해 간단한 CRUD 백엔드 어플리케이션을 만들어 보는 튜토리얼입니다.\n제 프리랜스 미션은 python으로 구현하는 것이었지만, node나 go 등의 훌륭한 언어를 통해서도 만들", "url": "https://velog.io/@ausg", "author": "AUSG"}]}